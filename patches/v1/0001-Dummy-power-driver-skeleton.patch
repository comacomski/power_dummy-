From 72ef23fec17bc97625aa0a0a83d991cfac7f015e Mon Sep 17 00:00:00 2001
From: Mico Antonic <coma.comski@gmail.com>
Date: Sat, 29 Nov 2025 12:59:17 +0100
Subject: [PATCH] Dummy power driver skeleton

Signed-off-by: Mico Antonic <coma.comski@gmail.com>
---
 drivers/power/supply/Kconfig      |   4 +
 drivers/power/supply/Makefile     |   1 +
 drivers/power/supply/dummypower.c | 135 ++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+)
 create mode 100644 drivers/power/supply/dummypower.c

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index dca4be23ee70..e25abf47e4a8 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -1097,4 +1097,8 @@ config FUEL_GAUGE_MM8013
 	  the state of charge, temperature, cycle count, actual and design
 	  capacity, etc.
 
+config DUMMY_PS
+	tristate "Dummy power supply driver for testing purposes"
+	default y
+
 endif # POWER_SUPPLY
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 99a820d38197..f087265505a7 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -125,3 +125,4 @@ obj-$(CONFIG_CHARGER_SURFACE)	+= surface_charger.o
 obj-$(CONFIG_BATTERY_UG3105)	+= ug3105_battery.o
 obj-$(CONFIG_CHARGER_QCOM_SMB2)	+= qcom_smbx.o
 obj-$(CONFIG_FUEL_GAUGE_MM8013)	+= mm8013.o
+obj-$(CONFIG_DUMMY_PS)                += dummypower.o
diff --git a/drivers/power/supply/dummypower.c b/drivers/power/supply/dummypower.c
new file mode 100644
index 000000000000..e13974d6f0a9
--- /dev/null
+++ b/drivers/power/supply/dummypower.c
@@ -0,0 +1,135 @@
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/device/driver.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
+
+#define DUMMY_NAME "Dummy_Driver"
+
+static enum power_supply_property dummy_prop[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_SCOPE,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,	
+};
+
+static int dummy_get_prop(struct power_supply *psy, enum power_supply_property psp, union power_supply_propval *val)
+{
+
+	pr_err("dummy get prop called; val=%s; int val = %d; prop = %d\n", val->strval, val->intval, psp);
+	val->intval = 0;
+	return 0;
+}
+
+static int dummy_set_prop(struct power_supply *psy, enum power_supply_property psp, const union power_supply_propval *val)
+{
+	pr_err("dummy set prop called!\n");
+	return 0;
+}
+
+static int dummy_prop_writeable(struct power_supply *psy, enum power_supply_property psp)
+{
+    pr_err("DUMMY_WRITEABLE\n");
+    switch (psp) {
+    case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+    case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+    case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+    case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+    case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+        return 1;  // writable properties
+
+    default:
+        return 0;  // read-only
+    }
+}
+
+static struct power_supply_desc dummy_ps_desc = {
+	.name = DUMMY_NAME,
+	.type = POWER_SUPPLY_TYPE_UNKNOWN,
+	.properties = dummy_prop,
+	.num_properties = 12,
+	.get_property = dummy_get_prop,
+	.set_property = dummy_set_prop,
+	.property_is_writeable = dummy_prop_writeable,
+
+};
+
+static struct power_supply_config dummy_ps_config = {};
+
+static struct power_supply *dummy_ps;
+
+static int dummy_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	dev_info(&pdev->dev, "Module probe called.\n");
+	dummy_ps = devm_power_supply_register(&pdev->dev, &dummy_ps_desc, &dummy_ps_config);
+	if(IS_ERR(dummy_ps))
+	{
+		dev_err(&pdev->dev, "Error while dev_power_supply_register:%ld\n", PTR_ERR(dummy_ps));
+		ret = PTR_ERR(dummy_ps);
+		goto reg_err;
+	}
+	dev_err(&pdev->dev, "Probe success! \n");	
+reg_err:
+	return ret;
+}
+static void dummy_remove(struct platform_device *pdev)
+{
+	pr_err("Dummy module remove called.\n");
+}
+
+static const struct of_device_id dummy_of[] = {
+	{ .compatible = "dt_string"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, dummy_of);
+
+static const struct acpi_device_id dummy_acpi[] = {
+    { "ABC1234", 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(acpi, dummy_acpi);
+
+struct platform_driver dummy_drv = {
+	.probe = dummy_probe,
+	.remove = dummy_remove,
+	.driver = {
+		.name = DUMMY_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = dummy_of,
+		.acpi_match_table = ACPI_PTR(dummy_acpi),
+	},
+	
+};
+
+struct platform_device *pdev;
+
+static int dummy_ps_init(void)
+{
+	pr_err("Dummy module init started...\n");
+	platform_driver_register(&dummy_drv);
+
+	// hack, delete
+	pdev = platform_device_register_simple(DUMMY_NAME, -1, NULL, 0);
+	
+	return 0;
+}
+static void dummy_ps_exit(void)
+{
+	pr_err("Dummy module exit \n");
+	
+}
+
+module_init(dummy_ps_init);
+module_exit(dummy_ps_exit);
-- 
2.43.0

